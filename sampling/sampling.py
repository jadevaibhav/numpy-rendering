# Enumerate the different importance sampling strategies we will implement
import numpy as np
from primitives import Rays
from utils import *

UNIFORM_SPH_SAMPLING, UNIFORM_HEMI_SPH_SAMPLING, COSINE_SAMPLING, LIGHT_SAMPLING, BRDF_SAMPLING, MIS_SAMPLING = range(6)
class Sampling(object):

    shadow_ray_o_offset = 3e-6

    def __init__(self,hit_points,normals,brdf_params,rays_w,sampling_type = None) -> None:
        self.sampling_type = sampling_type
        self.rays_w = rays_w
        self.hit_points = hit_points
        self.normals = normals
        self.brdf_params = brdf_params
        return
    
    def set_initial_params(self,hit_points,normals,brdf_params,rays_w):
        self.rays_w = rays_w
        self.hit_points = hit_points
        self.normals = normals
        self.brdf_params = brdf_params
        return 
    
    def set_light(self,light):
        self.light = light

    def shadow_rays(self):
        new_ray_dir,prob = self.sample()
        return Rays(self.hit_points + Sampling.shadow_ray_o_offset*self.normals, new_ray_dir),prob
    
    def sample(self,mask=None):
        """
        sample new rays from the hit points (generated by the rays).
        mask allows to select hit points for which directions will be sampled.
        """
        return
    
    def eval_prob_dist(self,dirs,mask=None):
        """ 
        evaluate the probability of given ray dirs under given sampling for MC sampling
        These rays can originate from different sampling dist.
        Mask allows to select hit points for which prob will be evaluated.
        """
        return
    
    def illumination(self,light_e,dirs,prob,mask=None):
        """
        for given sampled directions and their corresponding sampling prob, light_e gives the
        intensity value (light source ill*visibility) as evaluated by the scene.
        mask the initial params if mask given, for MIS.
        """
        alpha = self.brdf_params[mask][:,-1]
        specular_dot = np.sum( 
            reflect_along_normal(self.rays_w[mask],self.normals[mask])*dirs,
                axis=-1,keepdims=True)
        
        brdf = np.where((alpha == 1)[:,np.newaxis],
                    self.brdf_params[mask][:,:3]/np.pi,
                    self.brdf_params[mask][:,:3]*(alpha+1)[:,np.newaxis]/(2*np.pi)*np.maximum(0,(specular_dot)**(alpha[:,np.newaxis]))
                    )
        L_ill = light_e*brdf*np.maximum(0,(self.normals[mask]*dirs).sum(axis=-1,keepdims=True))/prob
        return L_ill
    
class UniformSphereSampling(Sampling):
    """
    implements both uniform spherical and hemi-spherical sampling.
    """

    def __init__(self, hit_points, normals, brdf_params, rays_w , sampling_type=None) -> None:
        assert sampling_type in [UNIFORM_SPH_SAMPLING,UNIFORM_HEMI_SPH_SAMPLING]   
        super().__init__(hit_points, normals, brdf_params, rays_w, sampling_type)

        return

    def eval_prob_dist(self,dirs,mask=None):
        if self.sampling_type == UNIFORM_SPH_SAMPLING:
            return 1/(4*np.pi)
        else:
            return 1/(2*np.pi)
        
    def sample(self,mask=None):
        ### random variables and converting into cannonical unit sphere samples
        
        rv1 = np.random.rand(self.hit_points[mask].shape[0])
        rv2 = 2*np.pi*np.random.rand(self.hit_points[mask].shape[0])
       
        w_z = 2*rv1 - 1
        r = np.sqrt(1 - w_z**2)
        w_x = r*np.cos(rv2)
        w_y = r*np.sin(rv2)
        w = np.stack([w_x,w_y,w_z],axis=-1)
        w = w/np.linalg.norm(w,axis=-1,keepdims=True)

        ### no need to rotate for uniform sphere
        if self.sampling_type == UNIFORM_SPH_SAMPLING:
            return w,1/(4*np.pi)
        else:
        ### we do dir hemisphere check with normal, flip dir if in lower hemisphere   
            hemi_check = np.sum(self.normals*w,axis=-1,keepdims=True) < 0
            ### np.where is slower
            #w = np.where(hemi_check < 0,-w,w)
            w[hemi_check] *= -1
            return w,1/(2*np.pi)
    
    def illumination(self, light_e,dirs=None,prob=None,mask=None):
        if dirs is None:
            dirs,prob = self.sample()
        return super().illumination(light_e, dirs, prob,mask)
        
class CosineSampling(Sampling):
    """
    implements cosine sampling.
    """

    def __init__(self, hit_points, normals, brdf_params, rays_w, sampling_type=COSINE_SAMPLING) -> None:
          
        super().__init__( hit_points, normals, brdf_params, rays_w, sampling_type)

        return

    def eval_prob_dist(self,dirs,mask=None):
        
        dot = np.sum(self.normals[mask]*dirs,axis=-1,keepdims=True)
        return np.maximum(dot,0)/np.pi
        
    def sample(self,mask=None):
        ### random variables and converting into cannonical unit sphere samples
       
        rv1 = np.random.rand(self.hit_points[mask].shape[0])
        rv2 = 2*np.pi*np.random.rand(self.hit_points[mask].shape[0])
        
        w_z = 2*rv1 - 1
        r = np.sqrt(1 - w_z**2)
        w_x = r*np.cos(rv2)
        w_y = r*np.sin(rv2)
        w = np.stack([w_x,w_y,w_z],axis=-1)
        w = w/np.linalg.norm(w,axis=-1,keepdims=True)
        w = w+self.normals
        w = w/np.linalg.norm(w,axis=-1,keepdims=True)
        
        ### The probability term will cancel out the dot product, hence just returning pi
        return w,1/np.pi
    
    def illumination(self, light_e,dirs=None,prob=None,mask=None):
        if dirs is None:
            dirs,prob = self.sample()
        alpha = self.brdf_params[mask][:,-1]
        specular_dot = np.sum( 
            reflect_along_normal(self.rays_w[mask],self.normals[mask])*dirs,
                axis=-1,keepdims=True)
        
        brdf = np.where((alpha == 1)[:,np.newaxis],
                    self.brdf_params[mask][:,:3]/np.pi,
                    self.brdf_params[mask][:,:3]*(alpha+1)[:,np.newaxis]/(2*np.pi)*np.maximum(0,(specular_dot)**(alpha[:,np.newaxis]))
                    )
        L_ill = light_e*brdf/prob

        return L_ill

class LightSampling(Sampling):
    """
    Implements light source solid angle sampling, for spherical light sources.
    """
    def __init__(self, hit_points, normals, light, brdf_params, rays_w, sampling_type=LIGHT_SAMPLING) -> None:
        super().__init__(hit_points, normals, brdf_params, rays_w, sampling_type)
        self.light = light
        

    def sample(self,mask=None):

        ### solid angle sampling towards the given light source
        
        solid_angle_cos = np.sqrt(
                                1 - np.clip(self.light.r**2/((self.light.c - self.hit_points[mask])**2).sum(axis=-1),0,1)
                                )
        
        phi = np.random.rand(self.hit_points[mask].shape[0])*2*np.pi

        w_z = 1 - np.random.rand(self.hit_points[mask].shape[0])*(1 - solid_angle_cos)
        w_c = (self.light.c - self.hit_points[mask])/np.linalg.norm((self.light.c - self.hit_points[mask]),axis=-1,keepdims=True)

        r = np.sqrt(1- w_z**2)
        w_x = r*np.cos(phi)
        w_y = r*np.sin(phi)
        w = np.stack([w_x,w_y,w_z],axis=-1)
        w = w/np.linalg.norm(w,axis=-1,keepdims=True)
        
        ### rotate z to w_c
        w = rotate_vectors(w,w_c)
        ### prob of sampling 1/solid angle
        solid_angle = 2*np.pi*(1 - solid_angle_cos[:,np.newaxis])
        
        return w,1/solid_angle

    def eval_prob_dist(self, dirs,mask=None):
        
        solid_angle_cos = np.sqrt(
                                    1 - np.clip(self.light.r**2/((self.light.c - self.hit_points[mask])**2).sum(axis=-1),0,1)
                                    )
        w_c =  (self.light.c - self.hit_points[mask])/np.linalg.norm((self.light.c - self.hit_points[mask]),axis=-1,keepdims=True)
        
        solid_angle = 2*np.pi*(1- solid_angle_cos[:,np.newaxis])
        dirs_dot_w_c = np.sum(dirs*w_c,axis=-1)
        solid_angle = 2*np.pi*(1 - solid_angle_cos)
        prob_dist_const = np.where(dirs_dot_w_c >= solid_angle_cos,1/solid_angle,0)

        return prob_dist_const[:,np.newaxis]
    
    def illumination(self,light_e,dirs=None,prob=None,mask=None):
        """
        light_e gives the intensity value (light source ill*visibility) as evaluated by the scene.
        IMP: light_e should only correspond given light source used in sampling, not all light sources.
        """
        if dirs is None:
            dirs,prob = self.sample()
        return super().illumination(light_e, dirs, prob,mask)

    

class BRDFSampling(Sampling):
    """
    Sample accroding the phong lobe depending on the alpha parameter.
    For alpha =1, diffuse surface, leads to cosine sampling.
    """
    def __init__(self, hit_points, normals, brdf_params, rays_w, sampling_type=BRDF_SAMPLING) -> None:
        super().__init__(hit_points, normals, brdf_params, rays_w, sampling_type)

    def sample(self,mask=None):
        
        w_z = np.random.rand(self.rays_w[mask].shape[0])**(1/(self.brdf_params[mask][:,-1]+1))
        r = np.sqrt(1 - w_z**2)
        phi = 2*np.pi*np.random.rand(self.rays_w[mask].shape[0])
        w_x = r*np.cos(phi)
        w_y = r*np.sin(phi)
        w = np.stack([w_x,w_y,w_z],axis=-1)
        w = w/np.linalg.norm(w,axis=-1,keepdims=True)
        
        # rotate the directions from z-axis to normal/ w_r, 
        # depending on material(diffuse or not)
        w_r = np.where((self.brdf_params[mask][:,-1] == 1)[:,np.newaxis],
                        self.normals[mask],
                        (self.rays_w[mask] + 2*(-self.rays_w[mask]*self.normals[mask]).sum(axis=-1,keepdims=True)*self.normals[mask]))
        
        rot_w = rotate_vectors(w,w_r)

        return rot_w,self.eval_prob_dist(rot_w)

    def eval_prob_dist(self, dirs,mask=None):
        specular_dot = np.sum(
                                (self.rays_w[mask] + 2*(-self.rays_w[mask]*self.normals[mask]).sum(axis=-1,keepdims=True)*self.normals[mask])*dirs,
                                axis=-1
                                )
        
        prob_dist_const =  np.where((self.brdf_params[mask][:,-1] == 1),
                    1/np.pi*np.maximum(0,(self.normals[mask]*dirs).sum(axis=-1)),
                    (self.brdf_params[mask][:,-1]+1)/(2*np.pi)*np.maximum(0,(specular_dot)**(self.brdf_params[mask][:,-1]))
                    )
            
        return prob_dist_const[:,np.newaxis]
    
    def illumination(self, light_e,dirs=None,prob=None,mask=None):
        if dirs is None:
            dirs,prob = self.sample()
        brdf = np.where((self.brdf_params[mask][:,-1] == 1)[:,np.newaxis],
                        self.brdf_params[mask][:,:3],
                        self.brdf_params[mask][:,:3]*np.maximum(0,(self.normals[mask]*dirs).sum(axis=-1,keepdims=True)))
        
        return light_e*brdf/prob

### TODO: think of masking strategy for MIS so that sampling is done just once, while eval is conducted on everything
### one way, different sampler per mask
### another way, allow passing masks, second seems better, prob add it to basic Sampling class 
### to support behaviour across all samplers
class MISampling(Sampling):

    def __init__(self, hit_points, normals, light, brdf_params, rays_w, sampling_type=MIS_SAMPLING) -> None:
        super().__init__(hit_points, normals, rays_w, sampling_type)
        self.light = light
        self.brdf_params = brdf_params
        ### coin toss to choose which strategy to sample
        self.coin_toss = np.random.rand(hit_points.shape[0]) < 0.5
        self.not_coin_toss = np.logical_not(self.coin_toss)
        #### dont need coin toss here as for any ray, we need prob from both distributions
        self.light_sampler = LightSampling(hit_points, normals, light, brdf_params,rays_w)
        self.brdf_sampler = BRDFSampling(hit_points, normals, brdf_params,rays_w)
    
    def sample(self):
        dirs = np.zeros_like(self.rays_w)
        prob = np.zeros((self.rays_w.shape[0],1))
        ### sample with one dist, just eval prob in another and take average 
        dirs[self.coin_toss],prob[self.coin_toss] = self.light_sampler.sample(self.coin_toss)
        prob_brdf_for_light = self.brdf_sampler.eval_prob_dist(dirs[self.coin_toss],self.coin_toss)
        prob[self.coin_toss] = (prob[self.coin_toss]+prob_brdf_for_light)/2

        dirs[self.not_coin_toss],prob[self.not_coin_toss] = self.brdf_sampler.sample(self.not_coin_toss)
        prob_light_for_brdf = self.light_sampler.eval_prob_dist(dirs[self.not_coin_toss],self.not_coin_toss)
        prob[self.not_coin_toss] = (prob[self.not_coin_toss]+prob_light_for_brdf)/2

        return dirs,prob
    
    def illumination(self, light_e, dirs=None,prob=None,mask=None):
        
        if dirs is None:
            dirs,prob = self.sample()
        L_ill = np.zeros_like(light_e)
        L_ill[self.coin_toss] = self.light_sampler.illumination(light_e[self.coin_toss],dirs[self.coin_toss],
                                                                prob[self.coin_toss],self.coin_toss)
        L_ill[self.not_coin_toss] = self.brdf_sampler.illumination(light_e[self.not_coin_toss],dirs[self.not_coin_toss],
                                                                   prob[self.not_coin_toss],self.not_coin_toss)
        
        return L_ill
